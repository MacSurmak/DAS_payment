[English](README.md) | [Русский](README.ru.md)

# DAS Payment Bot

[![Build and Push Docker Image](https://github.com/macsurmak/das-payment-bot/actions/workflows/deploy.yml/badge.svg)](https://github.com/macsurmak/das-payment-bot/actions/workflows/deploy.yml)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
![Python Version](https://img.shields.io/badge/python-3.13-blue)
![Powered by Aiogram](https://img.shields.io/badge/powered%20by-aiogram-blue.svg)

Телеграм-бот для электронной очереди в ДАС МГУ, разработанный с упором на чистую архитектуру, масштабируемость и простоту поддержки.

## Основные возможности

Проект придерживается строгого набора архитектурных принципов для обеспечения высокого качества кода и легкости его сопровождения:

*   **Декларативный UI (`aiogram-dialog`):** весь пользовательский интерфейс описан декларативно, что избавляет от "callback hell" и сложного управления состояниями FSM. Логика UI полностью изолирована от бизнес-логики.
*   **Разделение ответственности (SoC):** проект строго разделен на слои:
    *   `dialogs/`: определение UI (окна, переходы).
    *   `services/`: бизнес-логика (операции с БД, вычисления), полностью независимая от Telegram.
    *   `handlers/`: точки входа для команд (`/start`), которые запускают диалоги.
    *   `database/`: определение структуры данных (модели SQLAlchemy).
*   **База данных как единственный источник истины:** все изменяемые конфигурации (расписание, привязка факультетов к окнам, доступные даты) хранятся в базе данных PostgreSQL, а не в коде.
*   **Полная локализация (i18n):** ни одна строка, видимая пользователю, не зашита в коде. Весь текст управляется через централизованный модуль `lexicon/`, что упрощает перевод и изменение формулировок.
*   **Подход "ORM-first":** все взаимодействия с базой данных осуществляются через SQLAlchemy ORM, что обеспечивает типобезопасность, защиту от инъекций и читаемость кода.
*   **Полная асинхронность:** весь стек, от обработчиков `aiogram` до запросов к базе данных (`asyncpg`), является асинхронным для максимальной производительности.
*   **Готовность к production:** бот контейнеризирован с помощью Docker, включает эндпоинты для health check'ов в Kubernetes, а также имеет разделенные, автоматизированные процессы для уведомлений и самого бота.

## Стек технологий

*   **Фреймворк:** Aiogram 3
*   **UI:** aiogram-dialog
*   **База данных:** PostgreSQL
*   **ORM:** SQLAlchemy 2.0 (async)
*   **Кэш/FSM Storage:** Redis
*   **Логирование:** Loguru
*   **Уведомления:** APScheduler
*   **Контейнеризация:** Docker, Docker Compose

## Быстрый старт

Самый простой способ запустить проект локально — использовать Docker Compose.

### Требования

*   Docker
*   Docker Compose

### Установка

1.  **Склонируйте репозиторий:**
    ```bash
    git clone https://github.com/macsurmak/das-payment-bot.git
    cd das-payment-bot
    ```

2.  **Создайте файл конфигурации:**
    Скопируйте пример файла окружения и заполните его своими данными.
    ```bash
    cp .env.example .env
    ```
    Вам потребуется указать `BOT_TOKEN` и `ADMIN_IDS`. Настройки базы данных и Redis по умолчанию подходят для локальной разработки с Docker Compose.

3.  **Соберите и запустите контейнеры:**
    Эта команда соберет образ бота и запустит контейнеры с ботом, планировщиком, PostgreSQL и Redis.
    ```bash
    docker-compose up --build
    ```
    Теперь бот запущен в режиме long polling.

## Конфигурация

Вся конфигурация осуществляется через переменные окружения в файле `.env`:

*   `BOT_TOKEN`: токен вашего телеграм-бота.
*   `ADMIN_IDS`: список ID администраторов в Telegram, перечисленных через запятую.
*   `ADMIN_PASSWORD`: пароль для получения прав администратора через команду `/admin`.
*   `DB_*`: параметры подключения к базе данных PostgreSQL.
*   `REDIS_*`: параметры подключения к Redis.
*   `BASE_WEBHOOK_URL`, `WEBHOOK_PATH`: опциональные параметры для запуска бота в режиме вебхуков (рекомендуется для production).

## Развертывание

Проект спроектирован для контейнеризированного развертывания, например, с использованием Kubernetes.

1.  `Dockerfile` создает готовый для production образ.
2.  GitHub Actions workflow в `.github/workflows/deploy.yml` автоматически собирает и публикует образ в Docker Hub при каждом коммите в ветку `main`.
3.  Директория `k8s/` содержит примеры манифестов для развертывания бота и планировщика как отдельных сервисов (Deployment) в кластере Kubernetes.